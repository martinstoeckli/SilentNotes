@using SilentNotes.ViewModels
@model NoteViewModel
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <base href="@Model.HtmlBase">
    <title>SilentNotes</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no, user-scalable=no">

    <link href="bootstrap.min.css" rel="stylesheet" />
    <link href="silentnotes.css" rel="stylesheet" />
    <link href="@(Model.Theme.DarkMode ? "silentnotes.dark.css" : "silentnotes.light.css")" rel="stylesheet" />

    <script src="@Model.HtmlRecource["vuejs"]"></script>
    <script src="@Model.HtmlRecource["jqueryjs"]"></script>
    <script src="@Model.HtmlRecource["bootstrapjs"]"></script>
    <script src="@Model.HtmlRecource["bootstrapautocompletejs"]"></script>
    <script src="@Model.HtmlRecource["prosemirror"]"></script>
    <script src="silentnotes.js"></script>

    <style type="text/css">
body { background-color: transparent; }

.note-viewer {
    font-size: @(Model.NoteBaseFontSize)px !important;
}
div .detail-view.checklist .ProseMirror p::before { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("checkbox-blank-outline", new[] { new KeyValuePair<string, string>("fill", "#000000") }));}; }
div .detail-view.checklist .ProseMirror p.done::before { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("check-box-outline", new[] { new KeyValuePair<string, string>("fill", "#000000") }));}; }
div .detail-view.checklist .ProseMirror p.disabled::before { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("checkbox-blank-outline", new[] { new KeyValuePair<string, string>("fill", "#000000") }));}; }
div .detail-view.checklist .ProseMirror p::after { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("delete", new[] { new KeyValuePair<string, string>("fill", "#000000") }));}; }
div.dark .detail-view.checklist .ProseMirror p::before { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("checkbox-blank-outline", new[] { new KeyValuePair<string, string>("fill", "#FFFFFF") }));}; }
div.dark .detail-view.checklist .ProseMirror p.done::before { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("check-box-outline", new[] { new KeyValuePair<string, string>("fill", "#FFFFFF") }));}; }
div.dark .detail-view.checklist .ProseMirror p.disabled::before { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("checkbox-blank-outline", new[] { new KeyValuePair<string, string>("fill", "#FFFFFF") }));}; }
div.dark .detail-view.checklist .ProseMirror p::after { content: @{WriteLiteral(Model.Icon.LoadIconAsCssUrl("delete", new[] { new KeyValuePair<string, string>("fill", "#FFFFFF") }));}; }

.color-btn { color: black; }
.color-btn.dark { color: white; }
.locked {
    position: relative;
    height: 100%;
}
.locked svg {
    fill: rgba(160, 160, 160, 0.4);
}
    </style>
    <script>
        var editor;
        var ignoreViewModelUpdate = true;

        /* Starts notifying the viewmodel about changes. Call it as soon as the content is completely loaded. */
        function startSendingViewModelUpdates() {
            ignoreViewModelUpdate = false;
        }

        /* Notifies the viewmodel about changes in the note content. */
        function triggerViewModelUpdate() {
            if (!ignoreViewModelUpdate)
                vuePropertyChanged('UnlockedHtmlContent', null);
        }

        /* Collects all calls to triggerViewModelUpdate() and bundles them to a single call. */
        function bundleViewModelUpdates(delegate) {
            try {
                ignoreViewModelUpdate = true;
                delegate();
            }
            finally {
                ignoreViewModelUpdate = false;
            }
            triggerViewModelUpdate();
        }

        function getSearchDialogElement() {
            return document.getElementById('search-dialog');
        }

        function getTagsElement() {
            return document.getElementById('tags');
        }

        function toggleFormat(formatName, formatParameter) {
            ProseMirrorBundle.toggleFormat(editor, formatName, formatParameter);
            refreshActiveFormatState();
        }

        function refreshActiveFormatState() {
            vm.Header1Active = ProseMirrorBundle.isFormatActive(editor, 'heading', { level: 1 });
            vm.Header2Active = ProseMirrorBundle.isFormatActive(editor, 'heading', { level: 2 });
            vm.Header3Active = ProseMirrorBundle.isFormatActive(editor, 'heading', { level: 3 });
            vm.BoldActive = ProseMirrorBundle.isFormatActive(editor, 'bold');
            vm.ItalicActive = ProseMirrorBundle.isFormatActive(editor, 'italic');
            vm.UnderlineActive = ProseMirrorBundle.isFormatActive(editor, 'underline');
            vm.StrikeActive = ProseMirrorBundle.isFormatActive(editor, 'strike');
            vm.CodeActive = ProseMirrorBundle.isFormatActive(editor, 'codeblock');
            vm.QuoteActive = ProseMirrorBundle.isFormatActive(editor, 'blockquote');
            vm.ListBulletActive = ProseMirrorBundle.isFormatActive(editor, 'bulletlist');
            vm.ListOrderedActive = ProseMirrorBundle.isFormatActive(editor, 'orderedlist');
        }

        function undo() {
            editor.commands.undo();
        }

        function redo() {
            editor.commands.redo();
        }

        function addTag() {
            var tagText = getTagsElement().value.trim();
            if (vm.IsReadOnly || tagText === '')
                return;
            getTagsElement().value = '';
            vueCommandExecute('AddTagCommand', tagText);
        }

        function deleteTag(e) {
            if (vm.IsReadOnly)
                return;
            vueCommandExecute('DeleteTagCommand', e.currentTarget.attributes['data-tag'].value);
        }

        function getTagSuggestions() {
            return vm.$data.TagSuggestions.map(function (item) {
                return { value: item }
            });
        }

        function getNoteHtmlContent() {
            return editor.getHTML();
        }

        // By setting the content after loading the page, we can avoid that the content has to be
        // declared statically as javascript and therefore would occupy memory twice.
        function initializeNoteContent(text) {
            try {
                editor.chain().setMeta('addToHistory', false).setContent(text).scrollToTop().run();
            }
            catch (ex) {
                editor.setEditable(false);
                document.getElementById('myeditor').textContent = ex.message;
            }
        }

        function isSearchDialogHidden() {
            return getSearchDialogElement().classList.contains('hidden');
        }

        function toggleSearchDialog() {
            showSearchDialog(isSearchDialogHidden());
        }

        function showSearchDialog(visible) {
            if (visible) {
                // Open dialog
                var filter = ProseMirrorBundle.getSelectedText(editor);
                if (filter !== null) {
                    vm.SearchPattern = filter.trim();
                }
                getSearchDialogElement().classList.remove('hidden');
                document.getElementById('SearchPattern').focus();
                searchByFilter();
            }
            else {
                // Close dialog
                vm.SearchPattern = '';
                getSearchDialogElement().classList.add('hidden');
                searchByFilter();
            }
        }

        function searchByFilter() {
            ProseMirrorBundle.searchAndHighlight(editor, vm.SearchPattern);
        }

        function toggleShoppingMode() {
            vm.ShoppingModeActive = !vm.ShoppingModeActive;
            editor.setEditable(!vm.ShoppingModeActive);
        }

        function activateEditor() {
            if (editor && vm)
                editor.setEditable(!vm.ShoppingModeActive);
        }

        function vueLoaded() {
            var editorElement = document.getElementById('myeditor');
            editor = ProseMirrorBundle.initializeChecklist(editorElement);
            editor.on('selectionUpdate', function (editor) {
                refreshActiveFormatState();
            });
            editor.on('update', function (editor) {
                triggerViewModelUpdate();
            });
            ProseMirrorBundle.registerIsShoppingModeActive(function () { return vm.ShoppingModeActive; });

            @* // For debugging purposes, get the complete HTML in NoteController.ShowInView().
            editor.commands.setContent('@{WriteLiteral(Model.GetEscapedUnlockedHtmlContent());}'); *@

            // The 'input' event can be delayed for IME composition.
            var searchPatternElement = document.getElementById('SearchPattern');
            searchPatternElement.addEventListener('keyup', function (event) {
                vm.SearchPattern = searchPatternElement.value;
                searchByFilter();
                ProseMirrorBundle.selectNextWhileTyping(editor);
            });

            // Always start with editor in readonly mode.
            editor.setEditable(false);

            $("#tags").autocomplete({
                source: getTagSuggestions,
                treshold: 0,
                maximumItems: 10,
                value: "value",
                label: "value",
                dropType: "dropup",
                onSelectItem: function (item, inputField) {
                    addTag();
                },
            });
            getTagsElement().addEventListener("keyup", function(event) {
                if (event.key === 'Enter' || event.keyCode === 13) {
                    addTag();
                }
            });
        };

        @{WriteLiteral(Model.VueDataBindingScript);}
    </script>
</head>
<body><div id="vueDataBinding">
    <nav id="navigation" class="d-flex">
        <button class="nav-item mr-auto" v-on:click="GoBackCommand" title="@Model.Language["back"]">@{WriteLiteral(Model.Icon["arrow-left"]);}</button>

        @if (!Model.IsLocked)
        {
             
            <button class="nav-item" onclick="ProseMirrorBundle.moveChecklist(editor, true, false); return false;" v-bind:disabled="IsReadOnly" title="@Model.Language["checklist_move_to_top"]">@{WriteLiteral(Model.Icon["arrow-collapse-up"]);}</button>
            <button class="nav-item" onclick="ProseMirrorBundle.moveChecklist(editor, true, true); return false;" v-bind:disabled="IsReadOnly" title="@Model.Language["checklist_move_up"]">@{WriteLiteral(Model.Icon["arrow-up"]);}</button>
            <button class="nav-item" onclick="ProseMirrorBundle.moveChecklist(editor, false, true); return false;" v-bind:disabled="IsReadOnly" title="@Model.Language["checklist_move_down"]">@{WriteLiteral(Model.Icon["arrow-down"]);}</button>
            <button class="nav-item" onclick="ProseMirrorBundle.moveChecklist(editor, false, false); return false;" v-bind:disabled="IsReadOnly" title="@Model.Language["checklist_move_to_bottom"]">@{WriteLiteral(Model.Icon["arrow-collapse-down"]);}</button>
            <button class="nav-item" onclick="toggleShoppingMode(); return false;" v-bind:disabled="AutoSynchronizationRunning" v-bind:class="{ active: ShoppingModeActive }" title="@Model.Language["note_shopping_mode"]">@{WriteLiteral(Model.Icon["keyboard_off_outline"]);}</button>
            <button class="nav-item" onclick="toggleSearchDialog(); return false;" title="@Model.Language["search"]">@{WriteLiteral(Model.Icon["magnify"]);}</button>

            <div class="dropdown">
                <button class="nav-item" id="navOverflowMenu" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                    @{WriteLiteral(Model.Icon["dots-vertical"]);}
                </button>
                <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navOverflowMenu">
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" onclick="bundleViewModelUpdates(function () {ProseMirrorBundle.sortChecklistPendingToTop(editor)}); return false;">@{WriteLiteral(Model.Icon["sort-bool-descending-variant"]);} @Model.Language["checklist_move_pending_to_top"]</div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" onclick="bundleViewModelUpdates(function () {ProseMirrorBundle.sortChecklistAlphabetical(editor)}); return false;">@{WriteLiteral(Model.Icon["sort-alphabetical-ascending"]);} @Model.Language["checklist_sort_alphabetical"]</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" onclick="bundleViewModelUpdates(function () {ProseMirrorBundle.setCheckStateForAllToTodo(editor)}); return false;">@{WriteLiteral(Model.Icon["checkbox-multiple-blank-outline"]);} @Model.Language["checklist_uncheck_all"]</div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" onclick="bundleViewModelUpdates(function () {ProseMirrorBundle.setCheckStateForAllToDone(editor)}); return false;">@{WriteLiteral(Model.Icon["check-box-multiple-outline"]);} @Model.Language["checklist_check_all"]</div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" onclick="bundleViewModelUpdates(function () {ProseMirrorBundle.setCheckStateForAllToDisabled(editor)}); return false;">@{WriteLiteral(Model.Icon["checkbox-blank-off-outline"]);} @Model.Language["checklist_disable_all"]</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" v-bind:class="{ active: Header1Active, disabled: IsReadOnly }" onclick="toggleFormat('heading', 1);">@{WriteLiteral(Model.Icon["format-header-1"]);} @Model.Language["note_header1"]</div>
                    <div class="dropdown-item" v-bind:class="{ active: Header2Active, disabled: IsReadOnly }" onclick="toggleFormat('heading', 2);">@{WriteLiteral(Model.Icon["format-header-2"]);} @Model.Language["note_header2"]</div>
                    <div class="dropdown-divider"></div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" onclick="undo(); return false;"><svg width='128' height='128' viewBox='0 0 24 24'><use xlink:href="#svg-undo" /></svg> @Model.Language["undo"]</div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" onclick="redo(); return false;"><svg width='128' height='128' viewBox='0 0 24 24'><use xlink:href="#svg-redo" /></svg> @Model.Language["redo"]</div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" data-toggle="modal" data-target="#colorPaletteModal">@{WriteLiteral(Model.Icon["palette"]);} @Model.Language["note_colors"]</div>
                    @if (Model.CanKeepScreenOn)
                    {
                        <div class="dropdown-item" v-bind:class="{ active: KeepScreenOnActive }" v-on:click="KeepScreenOnCommand">@{WriteLiteral(Model.Icon["alarm-plus"]);} @Model.KeepScreenOnTitle</div>
                    }
                    <div class="dropdown-item" v-bind:class="{ active: IsPinned, disabled: IsReadOnly }" v-on:click="TogglePinnedCommand">@{WriteLiteral(Model.Icon["pin"]);} @Model.Language["note_pin"]</div>
                    <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" v-on:click="ShowInfoCommand">@{WriteLiteral(Model.Icon["information"]);} @Model.Language["note_show_info"]</div>
                    @if (Model.ShowManualSynchronization)
                    {
                        <div class="dropdown-divider"></div>
                        <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" v-on:click="PushNoteToOnlineStorageCommand">@{WriteLiteral(Model.Icon["cloud-upload"]);} @Model.Language["note_push_to_server"]</div>
                        <div class="dropdown-item" v-bind:class="{ disabled: IsReadOnly }" v-on:click="PullNoteFromOnlineStorageCommand">@{WriteLiteral(Model.Icon["cloud-download"]);} @Model.Language["note_pull_from_server"]</div>
                    }
                </div>
            </div>
        }
    </nav>

    <div id="content" v-bind:class="{ dark: IsDark }" v-bind:style="{ backgroundColor: BackgroundColorHex }">
        @if (Model.IsLocked)
        {
            <span class="locked d-flex justify-content-center align-items-center" v-bind:class="{ dark: IsDark }"><svg width='128' height='128' viewBox='0 0 24 24'><use xlink:href="#svg-lock-outline" /></svg></span>
        }
        else
        {
            <div id="myeditor" v-pre class="note-viewer detail-view @Model.CssClassNoteType"></div>
        }
    </div>

    <div id="tag-container" v-bind:class="{ dark: IsDark }">
        <div class="tag-input-group">
            <div class="input-group">
                <input id="tags" class="form-control" v-bind:disabled="IsReadOnly" placeholder='@Model.Language["tag_add"]' type="text">
                <div class="input-group-append">
                    <div id="add-tag" class="btn" onclick="addTag();"><svg width='16' height='16' viewBox='0 0 24 24'><use xlink:href="#svg-plus" /></svg></div>
                </div>
            </div>
        </div>
        <ul class="tag-list">
            <li class="tag-item" v-bind:style="{ backgroundColor: BackgroundColorHex }" v-for="Tag in Tags">
                {{Tag}}
                <div class="tag-handle" onclick="deleteTag(event);" v-bind:data-tag="Tag"><svg width='16' height='16' viewBox='0 0 24 24'><use xlink:href="#svg-delete" /></svg></div>
            </li>
        </ul>
    </div>

    <div id="search-dialog" class="hidden">
        <div class="nav-filter">
            <input id="SearchPattern" v-model="SearchPattern" type="text" autocomplete="off" />
            <svg id="search-next" width='24' height='24' viewBox='0 0 24 24' class="" v-on:click="FindNextCommand"><use xlink:href="#svg-chevron-down" /></svg>
            <svg id="search-previous" width='24' height='24' viewBox='0 0 24 24' class="" v-on:click="FindPreviousCommand"><use xlink:href="#svg-chevron-up" /></svg>
            <svg id="filter-cancel-icon" width='24' height='24' viewBox='0 0 24 24' class="" onclick="showSearchDialog(false);"><use xlink:href="#svg-close-circle-outline" /></svg>
        </div>
    </div>

    <div class="modal" id="colorPaletteModal" tabindex="-1" role="dialog" aria-hidden="true">
        <div class="modal-dialog modal-sm" role="document">
            <div class="modal-content p-2">
                <button type="button" class="close d-flex justify-content-end" data-dismiss="modal" aria-label="Close">
                    <span aria-hidden="true">&times;</span>
                </button>
                <div class="d-flex flex-wrap">
                    @foreach (var backgroundColor in @Model.BackgroundColorsHex)
                    {
                        <div class="d-flex align-items-center justify-content-center color-btn @Model.GetDarkClass(backgroundColor)" data-dismiss="modal" v-on:click="BackgroundColorHex='@(backgroundColor)'" style="background-color: @backgroundColor"><span>Lorem ipsum</span></div>
                    }
                </div>
            </div>
        </div>
    </div>

    <div hidden>
        @{WriteLiteral(Model.Icon.LoadIcon("lock-outline", new[] { new KeyValuePair<string, string>("id", "svg-lock-outline") }));}
        @{WriteLiteral(Model.Icon.LoadIcon("delete", new[] { new KeyValuePair<string, string>("id", "svg-delete") }));}
        @{WriteLiteral(Model.Icon.LoadIcon("close-circle-outline", new[] { new KeyValuePair<string, string>("id", "svg-close-circle-outline") }));}
        @{WriteLiteral(Model.Icon.LoadIcon("plus", new[] { new KeyValuePair<string, string>("id", "svg-plus") }));}
        @{WriteLiteral(Model.Icon.LoadIcon("chevron-up", new[] { new KeyValuePair<string, string>("id", "svg-chevron-up") }));}
        @{WriteLiteral(Model.Icon.LoadIcon("chevron-down", new[] { new KeyValuePair<string, string>("id", "svg-chevron-down") }));}
        @{WriteLiteral(Model.Icon.LoadIcon("undo", new[] { new KeyValuePair<string, string>("id", "svg-undo") }));}
        @{WriteLiteral(Model.Icon.LoadIcon("redo", new[] { new KeyValuePair<string, string>("id", "svg-redo") }));}
    </div>
</div></body>
</html>
