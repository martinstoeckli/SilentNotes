@inherits LayoutComponentBase

@using CommunityToolkit.Mvvm.Messaging
@using SilentNotes.Services

@inject IThemeService ThemeService
@inject IFeedbackService FeedbackService
@inject ISnackbar SnackbarService
@inject NavigationManager Navigation

@implements IDisposable

<style type="text/css">
	@ThemeService.CssTheme
</style>

<MudThemeProvider @bind-IsDarkMode="ThemeService.IsDarkMode" Theme="@ThemeService.Theme" />
<MudDialogProvider DisableBackdropClick="true" CloseOnEscapeKey="true"/>
<MudSnackbarProvider />

<MudLayout Class="@ThemeService.LightOrDarkClass">
	@Body
</MudLayout>

@if(FeedbackService.IsBusyIndicatorVisible)
{
	<MudProgressCircular id="progress" Indeterminate="true" Color="Color.Tertiary" Size="Size.Large" />
}

@code {
	private Guid _id = Guid.NewGuid();

	protected override void OnInitialized()
	{
		// Give other services a way to redraw the GUI of the whole app.
		WeakReferenceMessenger.Default.Register<RedrawMainPageMessage>(
			this, (recipient, message) => InvokeAsync(StateHasChanged));

		// Workaround: Scoped services are always correct when injected, but when adding them to
		// Ioc as scoped services, it seems they get lost, and when demanded the next time the Ioc
		// creates a new different service. Therefore we register the injected scoped objects
		// to scoped service providers.
		Ioc.Instance.GetService<IScopedServiceProvider<ISnackbar>>().Register(_id, SnackbarService);
		Ioc.Instance.GetService<IScopedServiceProvider<NavigationManager>>().Register(_id, Navigation);
	}

	protected override void OnAfterRender(bool firstRender)
	{
		if (firstRender)
		{
			WeakReferenceMessenger.Default.Send<MainLayoutReadyMessage>();
		}
	}

	/// <inheritdoc/>
	public void Dispose()
	{
		WeakReferenceMessenger.Default.Unregister<RedrawMainPageMessage>(this);

		Ioc.Instance.GetService<IScopedServiceProvider<ISnackbar>>().Unregister(_id);
		Ioc.Instance.GetService<IScopedServiceProvider<NavigationManager>>().Unregister(_id);
	}
}
